#ifndef TCP_SERVER
#define TCP_SERVER

#include <thread>
#include <memory>
#include "TcpConnection.hpp"
#include "Logger.hpp"
#include "IpStatistics.hpp"

#define MAXCONNECTIONS 10 // Max concurrent connections; probably should be based on specs

using namespace boost;

class TcpServer {
private:
    asio::ip::tcp::endpoint ep_;
    asio::io_context &context_;
    asio::ip::tcp::acceptor acceptor_;
    const Logger &log_; // logger to log info, it's shared between Server and all connections
    unsigned totalConnections_; // Total connections to this server
    std::shared_ptr<struct IpStatistics_t> ipStats_; // IpStatistics_t to gather stats, created by Server, shared with all connections
    // A vector of thread and TcpConnection pairs. Each TcpConnection handles a connection in an associated thread.
    std::vector<std::pair <std::thread,std::shared_ptr<TcpConnection>>> connectionThreads_;
    const int MAXALLOWEDERRORS = 5; // Max errors received from an IP before considering that IP as malicious and blocking it

    /*
    * Attempt to clear connections, this is called when MAXCONNECTIONS is reached.
    * A potential design is for the server could also call this function periodically to clean up stale connections
    * Or the Connection could notify the server to clean it up instead of calling this.
    */
    void clearConnections();

    /*
    * This handler is called when asio::ip::tcp::acceptor::async_accept accepts a connection
    * This function tries to accept or block the incoming connection
    * Then creates a new TcpConnection and starts reading on a child thread asynchronously 
    * Finally, it will start accepting again
    * 
    * param - system::error_code: error generated by async_accept
    * param - asio::ip::tcp::socket: socket created by async_accept to handle this connection
    */
    void acceptHandler(system::error_code, asio::ip::tcp::socket);

    /*
    * Whether to accept incoming connection or rejecting it
    * Currently, it just checks the amount of error previously received, and block it if too high
    * Potentially can be expanded for better security.
    * 
    * param - std::string &ip: The ip of the incoming connection
    * param - uint_least16_t port: The port of the incoming connection (currently unused)
    * 
    * return bool: whether to accept connection
    */
    bool acceptConnection(std::string &ip, const uint_least16_t port) const;

public:
    /*
    * class TcpServer - Constructor
    * Class to handle incoming connections. It also creates a IpStatistics_t for gathering stats
    * 
    * param - asio::io_context&: asio context of this server
    * param - asio::ip::tcp type: type of IP (i.e v4 or v6)
    * param - uint_least16_t port: the local port this server will listen on
    * param - Logger&: the logger to log info and errors
    */
    TcpServer(asio::io_context &, asio::ip::tcp type, uint_least16_t, Logger &);

    /*
    * Delete the copy and assignment constructors because we probably don't want to copy a TcpServer
    */
    TcpServer(const TcpServer&) = delete;
    TcpServer& operator=(const TcpServer&) = delete;

    /*
    * class TcpServer - Destructor
    * Destroys this server
    */
    ~TcpServer();

    /*
    * Start listening to connections using asio::ip::tcp::acceptor::async_accept
    * This also gets called by acceptHandler() so it can start accepting more connections
    */
    void StartListen();

    /*
    * Get the total connections so far
    *
    * return unsigned: the total connections to this Server
    */
    unsigned GetTotalConnections() const;

    /*
    * When this Server first opened
    *
    * return time_t: the time Server opened
    */
    time_t GetStartTime() const;
};

#endif
